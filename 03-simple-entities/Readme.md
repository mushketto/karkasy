# Лабораторна робота №2-3 Створення RestFull Api за допомогою фреймворків Laravel та NestJS

## Мета: Опановуння основних концепцій та паттернів розробки веб-додатків на прикладі фреймворків Laravel та NestJS.

### Теоритичні відомості

#### OpenAPI

Специфікація **OpenAPI** — це формат визначення мови, який використовується для опису RESTful API. Nest надає спеціальний модуль, який дозволяє генерувати таку специфікацію за допомогою декораторів.
Щоб почати використовувати його, ми спочатку встановимо необхідну залежність.

```bash
  npm install --save @nestjs/swagger swagger-ui-express
```
Після завершення процесу встановлення відкрийте main.js файл та ініціалізуйте Swagger за допомогою SwaggerModule класу:

```js
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import {DocumentBuilder, SwaggerModule} from "@nestjs/swagger";

async function bootstrap() {
   const app = await NestFactory.create(AppModule);

   const config = new DocumentBuilder()
           .setTitle('NestJs API Documentation')
           .setDescription('Backend API for the NestJs application.')
           .setVersion('1.0')
           .addTag('Tags')
           .build();

   const document = SwaggerModule.createDocument(app, config);
   SwaggerModule.setup('api', app, document);

   await app.listen(3000);
}
bootstrap();

```
Під час роботи програми відкрийте браузер і перейдіть до http://localhost:3000/api/docs. Ви повинні побачити інтерфейс Swagger.  

Як бачите, SwaggerModule автоматично відображаються всі ваші точку входу.

Щоб створити та завантажити JSON-файл Swagger, перейдіть до http://localhost:3000/api-json (за умови, що ваша документація Swagger доступна в розділі http://localhost:3000/api)

## Контроллери, постачальники та модулі

**Контролери** відповідають за обробку вхідних запитів і повернення відповідей клієнту.

Щоб створити базовий контролер, використовуються класи та декоратори. 
Декоратори пов’язують класи з необхідними метаданими та дозволяють Nest створювати карту маршрутизації (прив’язувати запити до відповідних контролерів).

```ts
// cats.controller.ts
import {Controller, Get} from '@nestjs/common';
import {CatsService} from "./cats.service";
import {Cat} from "./cat.interface";

@Controller('cats')
export class CatsController {
   constructor(private catsService: CatsService) {
   }

   @Get()
   async findAll(): Promise<Cat[]> {
      return this.catsService.findAll();
   }
}
```
**Постачальники (providers)** є фундаментальним поняттям у Nest. Багато базових класів Nest можуть розглядатися як постачальники – служби, репозиторії, фабрики, помічники тощо. 
Основна ідея провайдера полягає в тому, що його можна впровадити (inject) як залежність; 
це означає, що об’єкти можуть створювати різні зв’язки один з одним, а функцію «з’єднання» цих об’єктів можна значною мірою делегувати Nest.

Контролери повинні обробляти HTTP-запити та делегувати складніші завдання сервісам. 
**Сервіс** — це звичайні класи JavaScript, які оголошуються як providers у модулі.

Наприклад, CatsService відповідатиме за зберігання й пошук даних у CatsController, тому його можна визначити як постачальника.

```ts
// cats.service.ts

import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
   private readonly cats: Cat[] = [];

   create(cat: Cat) {
      this.cats.push(cat);
   }

   findAll(): Cat[] {
      return this.cats;
   }
}
```

**Ін'єкція залежності** - шаблону проектування,  що відповідає за впровадження залежностей. Наприклад, ви можете впровадити сервіс в контролер, щоб використовувати його функціональність.

```ts

constructor(private catsService: CatsService) {}

```


Модуль — це клас, анотований декоратором @Module(). Декоратор @Module() надає метадані, які Nest використовує для організації структури програми.

![img.png](assets%2Fimg.png)

Кожна програма має принаймні один модуль - кореневий. Кореневий модуль є відправною точкою, яку Nest використовує для побудови графіка додатка – внутрішньої структури даних, 
яку Nest використовує для вирішення зв’язків і залежностей між модулем і постачальником. 
Хоча дуже маленькі програми теоретично можуть мати лише кореневий модуль, це не типовий випадок. Слід підкреслити, 
що модулі настійно рекомендуються як ефективний спосіб організації ваших компонентів. Таким чином,
для більшості додатків результуюча архітектура буде використовувати кілька модулів, кожен з яких інкапсулює тісно пов’язаний набір можливостей.
Декоратор @Module() бере один об’єкт, властивості якого описують модуль:

| Назва | Опис                                                                                                                                                                                                 |
|---|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| providers	| постачальники, екземпляри яких буде створено в Nest і які можуть спільно використовуватися принаймні в цьому модулі                                                                                  |
| controllers	| набір контролерів, визначених у цьому модулі                                                                                                                                                         |
| imports | 	список  імпортованих модулів, які експортують постачальників, необхідних у цьому модулі                                                                                                             |
| exports | постачальники яка надаються цим модулем |

Модуль інкапсулює постачальників за замовчуванням. 
Це означає, що неможливо вставити постачальників, які не є ані безпосередньо частиною поточного модуля, ані експортованими з імпортованих модулів. 
Таким чином, ви можете розглядати експортовані провайдери з модуля як публічний інтерфейс модуля або API.

Модуль об'эднуэ сутності навколо певної функціональності або домену програми. Наприклад оберемо домен Cats. 
CatsController, CatsService  тісно пов’язані між собою і є сенс тримати їх у одному модулі. 
Модуль зберігаючи код упорядкованим і допомагає керувати складністю та розвиватися за принципами SOLID, особливо коли розмір програми та/або команди зростає.

Щоб продемонструвати, створимо CatsModule:

```ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import {CatsService} from "./cats.service";

@Module({
    controllers: [CatsController],
    providers: [CatsService]
})
export class CatsModule {}
```

### Завдання

1. Виконати клонування поточного проекту та встановити залежності.
2. Запустити та ознайомитися з існуючими модулями та функціоналом.
3. Встановити та налагодити роботу OpenAPI (Swagger), @nestjs/config.
4. Використовуючи nest CLI Створити модулі, контролери, сервіси, для сутностей визначених у [специфікації openAPI](node-api-spec.yaml).
5. Встановити та налагодити роботу TypeORM та підключити базу даних PostgreSQL.
6. Створити необхідні TypeORM сутності (включаючи зв'язки) та реалізувати сервіси з використанням репозиторіїв.
7. Самостійно опанувати документацію Laravel останньої версії та реалізувати аналогічний функціонал для сутності Subscriber згідно [специфікації](laravel-api-spec.yaml) та СКБД MySQL. 
8. Завантажити проект до власного репозиторію з назвою за шаблоном `<vendor>/backend-labs-2` на GitHub/Bitbucket та надати посилання на нього у якості звіту.

**Посилань на Документацію**

| Бібліотека | Посилання на документацію                                      |
|-------------|----------------------------------------------------------------|
| Laravel     | [Документація Laravel](https://laravel.com/docs)               |
| TypeORM     | [Документація TypeORM](https://github.com/typeorm/typeorm)        |

### Контрольні питання

1. Що таке OpenAPI, і яку роль вона відіграє у розробці RESTful API?
2. Які кроки потрібно виконати для встановлення та налаштування Swagger (OpenAPI) в NestJS за допомогою @nestjs/swagger та swagger-ui-express?
3. Що робить декоратор @Controller в NestJS, і як він використовується для організації маршрутів?
4. Як виглядає структура базового контролера в NestJS, і як він обробляє HTTP-запити?
5. Як визначається та використовується сервіс в контролері?
6. Що таке ін'єкція залежності, і чому вона важлива в розробці за принципами SOLID?
7. Які є основні поняття та роль постачальників в NestJS?
8. Як створити та налаштувати модуль в NestJS? Які властивості декоратора @Module?
9. Як об'єднати контролер, сервіс та модуль для сутності в NestJS?
10. Що таке TypeORM, і як його підключити до проекту NestJS?
11. Як створити та використовувати міграції в TypeORM для роботи з базою даних?
12. Як використовувати репозиторій для здійснення CRUD операцій з базою даних в NestJS?

## Як користуватись цим репозиторієм

### Передумови

Для роботи з цим репозиторієм вам знадобиться встановлені на вашому комп'ютері наступні програми:

- Docker and Docker-compose
- Git 
- Node.js

### Як запустити цей проект

1. Клонуйте цей репозиторій на свій комп'ютер
2. Перейдіть у директорію frontend та виконайте команду
```bash
  npm install
```
3. Поверніться у корневу директорію та виконайте команду
```bash
  docker-compose up -d
```  
4. Зайдіть у контейнер з php та виконайте команду
```bash
  docker exec -it <php container id or name> /bin/bash
  cd /app
  composer install
```
3. Перейдіть у директорію node-app та виконайте команду
```bash
  npm install
```
5. Відкрийте ваш браузер та перейдіть за посиланням http://localhost:8000

6. Зупинити проект можна виконавши команду
```bash
  docker-compose down
``` 

## Додаткові матеріали

- https://medium.com/@abdullahirfan99_80517/mastering-database-migrations-in-nestjs-d1b586be3490
